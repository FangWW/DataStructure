# dataStructure
personal review


``` 
穷举法、分治法、贪心法、动态规划法、回溯法、分枝限界法
1.数据存储的目的是便于数据访问。这个关系就是数据结构
2.算法是计算机解题的模型：输入，输出，顺序执行，跳转，循环，分支，有限步骤。
3.人大脑组织数据的方式 有线，树，图三种逻辑结构，而计算机存储采用顺序，链式和两者混合的方式。前者是概念性的东西，后者是物理实现。
4.线形结构：算法是迭代算法，你只要注意规模最小的情况下不出错，则算法一般不出错
   树形结构：算法是递归算法，你只要运用递归组合的方法，将简单情形组合出复杂情形
                     简单情形不出错，则算法一般不会出错。
   图形结构：DFS：将图按照树形结构来处理，运用递归算法
                     BFS：将图按章线形结构来处理，运用迭代算法
必须会下面几个几个算法：
（线形两个）   
  1.将两个有序表合并为一个表，这个算法的变种很多，可以是链表，顺序表。涉及集合运算，
      归并排序，字符串处理。
  2.将一个顺序表的元素重新划分，左边的较小，右边较大。涉及快速排序，求字符串的逆串。
 （树形若干个）注意：有些可以实现，有些实现不了，可以拿来思考。
  3.前序线索化，递归实现，栈模拟递归，非栈式迭代实现。
  4.中序线索化，递归实现，栈模拟递归，非栈式迭代实现。
  5.后序线索化，递归实现，栈模拟递归，非栈式迭代实现。
  （图形）注意：会画表格，写出算法的逐个步骤即可。
  6.MST:prim,kruskal
  7.short path:Dijkstra ,Floyd
  8.AOV:拓扑排序的DFS，BFS实现
  9.AOE：关键路径

kmp 字符匹配 利用之前已知的数据最大限度跳过绝对不可能匹配上的数据  需要维护一个next数值
　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2

(1)完全二叉树——只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；
(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树,。

各类Tree总结： (二分查找)     
       B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
       B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
       B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
       B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；

树的操作核心在于递归
f(node){
f(node.leftnext)
f(node.rightnext)
}
前中后 遍历 在于打日志的位置

二叉树中的插入，主要分两步：查找、插入 (插入到最后)

AVL树 红黑树???
平衡二叉树，又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差之差的绝对值不超过1.。
常用算法有：红黑树、AVL树、Treap等。

线索二叉树 中序排列后 将空节点指向前后节点

hash表 通过%取余数 分类 数组下标 相同下标放于链表后面

图成树就是：生成树是将图中所有顶点以最少的边连通的子图。 最少边数量=顶点数-1


BFS，其英文全称是Breadth First Search。 BFS并不使用经验法则算法。从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实验里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）


最小生成树
假如有10个点，你可以用9条线把这10个点连起来，不漏掉任何一个点，
然后这9条边的权值最小，就是最小生成树了
就是用小于顶点个数-1的边，连接所有点，权值最小。

HashTable 核心数据 数组 数组元素是linkedlist

